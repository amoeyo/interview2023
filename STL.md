# STL

## 模板的编译与链接

[参考](https://blog.csdn.net/c_base_jin/article/details/72861789)

模板是C++泛型编程的基础，一个模板就是一个创建类或者函数的公式；在具体使用时，我们需要将模板参数转化为具体类型，比如int,float,Vector以及自定义类型；**这种转换过程发生在编译阶段**。

类模板和函数模板的不同是，使用类模板时必须显式指定类型信息

模板可被编译器产生多种多样函数和类的代码。只有当被使用的时候，编译器才会产生用于这种类型的代码。模板不是直接编译成以后需要的各种类的实现，而是将模板代码解析放入内存中，当编译某个编译单元需要用到该模板，才会按需产生相应的代码。**实例化是编译器确定特定模板与特定参数集一起使用并在模板上执行参数替换以生成要编译的类或函数以及最终编译为模板的二进制代码的过程**。（根据具体类型产生不同的二进制代码）

有两种类型模板实例化，隐式和显式。**显式**实例化由程序员直接指定类型。这个过程会实例化所有的成员函数。**隐式**实例化是一种按需实例化，当使用一个模板类时，编译器才会进行实例化。例如如果你使用vector，此时编译器才会创建一个vector类型，并且只会实例化所需要的函数。不实例化所有的成员函数主要有两点原因：1、节省编译时间；2、不同的成员函数对类型属性有一些要求，不实例化可以使得更多的类型可以用到模板类。**例如map的operator[]操作符要求value是有默认构造函数的，因为你通过不存在的key访问value的时候会新建一个value，且是需要调用默认构造函数**。如果你不需要这个操作，用find和insert也可以达到目标，这样对value的类型就少了一个限制，使得模板类更具有普适性。

**虚函数不能写成模板函数**，因为虚函数执行的是动态绑定，在编译期间，对于本文件而言，编译器无法确定其它文件对该虚函数的调用情况，也就无法确定对于这个模板函数的实例化个数。如果将虚函数设置为模板函数，那么在编译阶段就无法确定虚函数表的大小（不同的类型可能会生成不同的函数代码，func<T>可能有多个），而虚函数表必须是fixed-size的。

在C++ 的类中，除了类模板参数之外，无法在不同的成员（函数、数据成员）之间共享类型信息，template本质还是为不同类型的类生成不同的代码，并不能达到把不同的类型对象赋给同一类型对象的目的，而使用void*转换会丢失对象原本的类型信息，使得拷贝等操作变得困难

使用boost::any或boost::function执行类型擦除，避开静态编译期间的类型检查。boost::any是一个保存了原始类型信息并将对象转换为统一类型的模板类


## STL

容器，算法，迭代器，仿函数，适配器，配置器

SGI STL构造由::construct进行，析构由::destroy负责

空间分配由alloc::allocator负责，释放由alloc::deallocate负责

### STL空间配置器

一级配置器和二级配置器

自由链表和内存池

一级配置器：对于大于128B的内存，直接使用malloc和free，模拟C++的set_new_handler处理内存不足的情况。线程安全

> 分配内存时，如果每次new出来 ，都要判断是否成功（地址是否为空），比较繁琐。c++提供set_new_handler，当new失败时，会调用用户通过set_new_handler设置的回调函数。

> [关于malloc线程安全的问题](./C++.md/#malloc分配规则内存边界对齐及malloc的线程安全) 

二级配置器：内存池，维护16个自由链表，负责16种小型区块的次配置能力

### unordered_map解决hash冲突的方法

[参考](https://zhuanlan.zhihu.com/p/346539485)

首选开链法

超过一定阈值（6）链表构建红黑树，低于一定阈值（8）红黑树退化为链表

当出现严重的hash冲突，会造成`bucket[idx]`指向的链表节点很长，此时搜索和删除一个节点的时间复杂度最坏却可能变成O(N)，即哈希表已经退化成链表，那么就违背了一开始设计hashtable的初衷，即弥补数组O(N)的搜索、删除时间复杂度。

为了解决hash退化，引入了两个概念：

- 负载因子（load_factor），是hashtable的元素个数与hashtable的桶数之间比值；
- 最大负载因子（max_load_factor），是负载因子的上限

load_factor = map.size() / map.buck_count()

*// load_factor 计算方式*

load_factor <= max_load_factor

*// 限制条件*

当hashtable中的元素个数与桶数比值load_factor >= max_load_factor时，hashtable就自动发生Rehash行为，来降低load_factor：

- 扩容。即分配一块更大内存，来容纳更多的桶。
- 重新插入。按照上述插入步骤将原来桶中的buck_size个节点重新插入到新的桶中。

此过程的时间复杂度为O(n)

也可以采用均摊/分摊的思想搬移数据

先申请相应大小的容量空间。

其次，在每一次插入数据的时候进行搬移：先将所需插入的数据放入到新哈希表中，然后将从旧的哈希表中拿出一个数据放到新的哈希表中。

最后，如果有任何涉及到查询的操作，先对新的哈希表进行查询再到旧的哈希表进行查询。

这样扩容操作效率就高了很多。在加倍扩容机制中，分摊时间复杂度之后，其扩容是时间复杂度为`O(1)`。

合适的装载因子（Java为0.75，msvc和g++默认为1）：可以使现有容量的利用率和需要扩容的频繁度可以较好的协调，不会过早的扩容导致空间和时间的浪费也不会太晚扩容导致哈希冲突发生过多。

### 容器的线程安全

- 多个读取者是安全的。多线程可能同时读取一个容器的内容，这将正确地执行。当然，在读取时不能有任何写入者操作这个容器。
- 对不同容器的多个写入者是安全的。多线程可以同时写不同的容器。

线程不安全的情况

- 在对同一个容器进行多线程的读写、写操作时。
- 在每次调用容器的成员函数期间都要锁定该容器。
- 在每个容器返回的迭代器（例如通过调用begin或end）的生存期之内都要锁定该容器。
- 在每个在容器上调用的算法执行期间锁定该容器。





